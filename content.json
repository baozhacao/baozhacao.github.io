{"meta":{"title":"爆炸小站","subtitle":"","description":"牛马志豪的Vlog","author":"无用的人","url":"http://baozhacao.github.io","root":"/"},"pages":[{"title":"categories","date":"2022-01-20T07:53:53.000Z","updated":"2022-01-20T07:57:05.110Z","comments":true,"path":"categories/index.html","permalink":"http://baozhacao.github.io/categories/index.html","excerpt":"","text":""},{"title":"404","date":"2022-01-20T07:39:12.000Z","updated":"2022-01-20T07:39:12.778Z","comments":true,"path":"404/index.html","permalink":"http://baozhacao.github.io/404/index.html","excerpt":"","text":""},{"title":"contact","date":"2022-01-22T13:16:24.000Z","updated":"2022-01-22T13:17:03.335Z","comments":true,"path":"contact/index.html","permalink":"http://baozhacao.github.io/contact/index.html","excerpt":"","text":""},{"title":"about","date":"2022-01-20T07:39:01.000Z","updated":"2022-01-20T08:07:44.452Z","comments":true,"path":"about/index.html","permalink":"http://baozhacao.github.io/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-01-21T03:56:16.000Z","updated":"2022-01-21T03:56:46.950Z","comments":true,"path":"friends/index.html","permalink":"http://baozhacao.github.io/friends/index.html","excerpt":"","text":""},{"title":"search","date":"2022-01-20T07:39:01.000Z","updated":"2022-01-20T07:59:14.528Z","comments":true,"path":"search/index.html","permalink":"http://baozhacao.github.io/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-01-20T07:39:01.000Z","updated":"2022-01-20T08:08:16.096Z","comments":true,"path":"tags/index.html","permalink":"http://baozhacao.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"常见的布局模式","slug":"常见的布局模式","date":"2023-02-04T06:34:26.000Z","updated":"2023-02-19T04:20:33.866Z","comments":true,"path":"2023/02/04/chang-jian-de-bu-ju-mo-shi/","link":"","permalink":"http://baozhacao.github.io/2023/02/04/chang-jian-de-bu-ju-mo-shi/","excerpt":"","text":"1.流式布局 最普通的盒子布局。 2. Flex布局 Flex意为”弹性布局”，用来为盒状模型提供最大的灵活性。 duisplay:flex Flex布局父容器的属性 决定主轴的方向（即项目的排列方向） flex-direction: row | row-reverse | column | column-reverse; 决定换不换行 flex-wrap: nowrap | wrap | wrap-reverse; 定义了项目在主轴上的对齐方式。 justify-content: flex-start | flex-end | center | space-between | space-around; 定义项目在交叉轴上如何对齐。 align-items: flex-start | flex-end | center | baseline | stretch; 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。(有多行项目，必须是设置换行) align-content: flex-start | flex-end | center | space-between | space-around | stretch; Flex布局子容器的属性 flex 给个固定的数值，可以设置属性所占的比例大小 align-self: auto | flex-start | flex-end | center | baseline | stretch align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch 3. 媒体查询语法 媒体查询@media可以针对不同屏幕尺寸设置不同样式。 @media 媒体类型 关键字and|not|only(媒体特性)&#123; css-code &#125; 媒体类型一般用screen，用于电脑屏幕，手机平板等。 媒体特性：width，min-width，max-width 可以针对不同的媒体使用不同 stylesheets : &lt;link rel=\"stylesheet\" media=\"mediatype and|not|only (media feature)\" href=\"mystylesheet.css\"> 4. rem布局 em：根据父盒子设置的font-size大小，相应的扩大子盒子十倍单位。这样的缺点是，页面上有大大小小的盒子，一个一个设置太麻烦。 rem：根据html设置的font-size大小，相应的扩大子盒子十倍单位。这样就可以使页面等比例缩放。 5. 响应式布局 响应式开发原理：通过媒体查询针对不同设备进行布局和样式的设置，达到适配不同设备的目的。 Bootstrap栅格式布局","categories":[{"name":"布局模式","slug":"布局模式","permalink":"http://baozhacao.github.io/categories/%E5%B8%83%E5%B1%80%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://baozhacao.github.io/tags/HTML/"},{"name":"Flex，布局","slug":"Flex，布局","permalink":"http://baozhacao.github.io/tags/Flex%EF%BC%8C%E5%B8%83%E5%B1%80/"}]},{"title":"js实现call-apply-bind","slug":"js实现call-apply-bind","date":"2023-02-01T04:46:23.000Z","updated":"2023-02-19T04:19:12.708Z","comments":true,"path":"2023/02/01/js-shi-xian-call-apply-bind/","link":"","permalink":"http://baozhacao.github.io/2023/02/01/js-shi-xian-call-apply-bind/","excerpt":"","text":"1.什么是call-apply-bind call-apply-bind是JavaScript中三个函数，用来改变函数执行上下文，也就是改变函数运行时this的指向。 关于this指向问题具体请看js函数中this指向问题 2.call-apply-bind区别与联系 apply和call基本类似，他们的区别只是传入的参数不同。前者传入的是一个数组，后者传入一个一个值。 bind方法会创建一个新的函数，并返回一个新的函数。当被调用的时候，将其this关键字设置为提供的值，我们必须手动去调用。与上面二者的区别是不能立即执行，要手动调用返回的函数之后才会执行。 // call,apply,bind使用 child.showName.call(obj,s1,s2); child.showName.apply(obj,[s1,s2]); let bind = child.showName.bind(obj); // 返回一个函数 bind(); // tony 3.一些开发中的应用 啥也不说了直接上代码 究其原理就是把当前this的指向给固有的方法，调用其函数。 //例子1：求数组中的最值 let arr1 = [1, 2, 19, 6]; console.log(Math.max.call(null, 1,2,19,6)); // 19 console.log(Math.max.call(null, arr1)); // NaN console.log(Math.max.apply(null, arr1)); // 19 直接可以用arr1传递进去 //例子2：将伪数组转化为数组（含有length属性的对象，dom节点, 函数的参数arguments） let div = document.getElementsByTagName('div'); //因为div是伪数组，所以不能直接调用slice（截取）方法，用call方法把this指向div，把参数全拿出来，间接转化成一个数组。 let arr2 = Array.prototype.slice.call(div); //let args = [].slice.call(arguments, 0); 4.js模拟实现call-apply-bind call // 给所有的函数添加一个hycall的方法 Function.prototype.hycall = function(thisArg, ...args) &#123; // 在这里可以去执行调用的那个函数(foo) // 问题: 得可以获取到是哪一个函数执行了hycall // 1.获取需要被执行的函数 var fn = this // 2.对thisArg转成对象类型(防止它传入的是非对象类型) thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg): window // 3.调用需要被执行的函数 thisArg.fn = fn var result = thisArg.fn(...args) delete thisArg.fn // 4.将最终的结果返回出去 return result &#125; function foo() &#123; console.log(\"foo函数被执行\", this) &#125; function sum(num1, num2) &#123; console.log(\"sum函数被执行\", this, num1, num2) return num1 + num2 &#125; // 系统的函数的call方法 foo.call(undefined) var result = sum.call(&#123;&#125;, 20, 30) // console.log(\"系统调用的结果:\", result) // 自己实现的函数的hycall方法 // 默认进行隐式绑定 // foo.hycall(&#123;name: \"why\"&#125;) foo.hycall(undefined) var result = sum.hycall(\"abc\", 20, 30) console.log(\"hycall的调用:\", result) apply Function.prototype.hyapply = function(thisArg, argArray) &#123; // 1.获取到要执行的函数 var fn = this // 2.处理绑定的thisArg thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg): window // 3.执行函数 thisArg.fn = fn var result // if (!argArray) &#123; // argArray是没有值(没有传参数) // result = thisArg.fn() // &#125; else &#123; // 有传参数 // result = thisArg.fn(...argArray) // &#125; // argArray = argArray ? argArray: [] argArray = argArray || [] result = thisArg.fn(...argArray) delete thisArg.fn // 4.返回结果 return result &#125; function sum(num1, num2) &#123; console.log(\"sum被调用\", this, num1, num2) return num1 + num2 &#125; function foo(num) &#123; return num &#125; function bar() &#123; console.log(\"bar函数被执行\", this) &#125; bind Function.prototype.hybind = function(thisArg, ...argArray) &#123; // 1.获取到真实需要调用的函数 var fn = this // 2.绑定this thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg): window function proxyFn(...args) &#123; // 3.将函数放到thisArg中进行调用 thisArg.fn = fn // 特殊: 对两个传入的参数进行合并 var finalArgs = [...argArray, ...args] var result = thisArg.fn(...finalArgs) delete thisArg.fn // 4.返回结果 return result &#125; return proxyFn &#125; function foo() &#123; console.log(\"foo被执行\", this) return 20 &#125; function sum(num1, num2, num3, num4) &#123; console.log(num1, num2, num3, num4) &#125; // 系统的bind使用 var bar = foo.bind(\"abc\") bar() var newSum = sum.hybind(\"abc\", 10, 20) var result = newSum(30, 40)","categories":[{"name":"js高级","slug":"js高级","permalink":"http://baozhacao.github.io/categories/js%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"call","slug":"call","permalink":"http://baozhacao.github.io/tags/call/"},{"name":"apply","slug":"apply","permalink":"http://baozhacao.github.io/tags/apply/"},{"name":"bind","slug":"bind","permalink":"http://baozhacao.github.io/tags/bind/"}]},{"title":"es6+之Set-Map","slug":"es6+之Set-Map","date":"2023-01-24T07:06:40.000Z","updated":"2023-02-19T04:17:46.439Z","comments":true,"path":"2023/01/24/es6-zhi-set-map/","link":"","permalink":"http://baozhacao.github.io/2023/01/24/es6-zhi-set-map/","excerpt":"","text":"Set1.Set的基本使用 在ES6之前，我们存储数据的结构主要有两种：数组、对象。 在ES6中新增了另外两种数据结构：Set、Map，以及它们的另外形式WeakSet、WeakMap。 Set是一个新增的数据结构，可以用来保存数据，类似于数组，但是和数组的区别是元素不能重复。 创建Set我们需要通过Set构造函数. Set有一个非常常用的功能就是给数组去重。 //创建Set const set1 = new Set(); set1.add(10) set1.add(20) set1.add(30) console.log(set1)//set(3)&#123;10,20,30&#125; //给数组去重 const arr = [10,20,10,30] const set = new Set(arr) const newArray1 = [...set] //const newArray1 = Array.from(set) 2.Set的常见方法 Set常见的属性： size：返回Set中元素的个数； Set常用的方法： add(value)：添加某个元素，返回Set对象本身； delete(value)：从set中删除和这个值相等的元素，返回boolean类型； has(value)：判断set中是否存在某个元素，返回boolean类型； clear()：清空set中所有的元素，没有返回值； forEach(callback, [, thisArg])：通过forEach遍历set；（也支持for of遍历） 3.WeakSet使用和Set类似的另外一个数据结构称之为WeakSet，也是内部元素不能重复的数据结构。 WeakSet中只能存放对象类型，不能存放基本数据类型； WeakSet对元素的引用是弱引用，如果没有其他引用对某个对象进行引用，那么GC可以对该对象进行回收； 关于强引用和弱引用请看：js强引用和弱引用 const weakSet = new WeakSet() weakSet.add(10)//TypeError: Invalid value used in weak set WeakSet常见的方法： add(value)：添加某个元素，返回WeakSet对象本身； delete(value)：从WeakSet中删除和这个值相等的元素，返回boolean类型; has(value)：判断WeakSet中是否存在某个元素，返回boolean类型； 注意：WeakSet不能遍历 因为WeakSet只是对对象的弱引用，如果我们遍历获取到其中的元素，那么有可能造成对象不能正常的销毁。 应用场景 // 3.WeakSet的应用场景 const personSet = new WeakSet() class Person &#123; constructor() &#123; personSet.add(this) &#125; running() &#123; if (!personSet.has(this)) &#123; throw new Error(\"不能通过非构造方法创建出来的对象调用running方法\") &#125; console.log(\"running~\", this) &#125; &#125; let p = new Person() p.running() p = null p.running.call(&#123;name: \"why\"&#125;) Map1.Map的基本使用 Map，用于存储映射关系。 与对象映射关系的区别 对象存储映射关系只能用字符串（ES6新增了Symbol）作为属性名（key）； 某些情况下我们可能希望通过其他类型作为key，比如对象，这个时候会自动将对象转成字符串来作为key； const map = new Map() map.set(obj1, \"aaa\") map.set(obj2, \"bbb\") map.set(1, \"ccc\") console.log(map) const map2 = new Map([[obj1, \"aaa\"], [obj2, \"bbb\"], [2, \"ddd\"]]) console.log(map2) 2.Map的常用方法 Map常见的属性： size：返回Map中元素的个数; Map常见的方法： set(key, value)：在Map中添加key、value，并且返回整个Map对象； get(key)：根据key获取Map中的value； has(key)：判断是否包括某一个key，返回Boolean类型； delete(key)：根据key删除一个键值对，返回Boolean类型； clear()：清空所有的元素； forEach(callback, [, thisArg])：通过forEach遍历set；（也支持for of遍历） 3.WeakMap的使用和Map类型相似的另外一个数据结构称之为WeakMap，也是以键值对的形式存在的。 WeakMap的key只能使用对象，不接受其他的类型作为key； WeakMap的key对对象想的引用是弱引用，如果没有其他引用引用这个对象，那么GC可以回收该对象； 关于强引用和弱引用请看：js强引用和弱引用 WeakMap常见的方法： set(key, value)：在Map中添加key、value，并且返回整个Map对象； get(key)：根据key获取Map中的value； has(key)：判断是否包括某一个key，返回Boolean类型； delete(key)：根据key删除一个键值对，返回Boolean类型； 4.WeakMap的应用 在vue3响应式原理中作用很大，什么是响应式原理呢？简单来说就是定义一个变量和一个函数，要求每当这个变量发生改变时，函数就随之执行一次。也就是说这个变量要被监听。 // 应用场景(vue3响应式原理) const obj1 = &#123; name: \"why\", age: 18 &#125; function obj1NameFn1() &#123; console.log(\"obj1NameFn1被执行\") &#125; function obj1NameFn2() &#123; console.log(\"obj1NameFn2被执行\") &#125; function obj1AgeFn1() &#123; console.log(\"obj1AgeFn1\") &#125; function obj1AgeFn2() &#123; console.log(\"obj1AgeFn2\") &#125; // 1.创建WeakMap const weakMap = new WeakMap() // 2.收集依赖结构 // 2.1.对obj1收集的数据结构，能遍历 const obj1Map = new Map() obj1Map.set(\"name\", [obj1NameFn1, obj1NameFn2]) obj1Map.set(\"age\", [obj1AgeFn1, obj1AgeFn2]) weakMap.set(obj1, obj1Map) // Proxy/Object.defineProperty // 3.如果obj1.name发生了改变 obj1.name = \"james\" //找到obj1对应的obj1Map，targetMap就是obj1Map了 const targetMap = weakMap.get(obj1) //找到obj1Map中的name，name对应的是两个函数 const fns = targetMap.get(\"name\") //遍历实现这两个函数完成响应 fns.forEach(item => item()) //map能遍历，weakMap不能，但他能垃圾回收，所以用它来实现","categories":[{"name":"es6","slug":"es6","permalink":"http://baozhacao.github.io/categories/es6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://baozhacao.github.io/tags/es6/"},{"name":"Set","slug":"Set","permalink":"http://baozhacao.github.io/tags/Set/"},{"name":"Map","slug":"Map","permalink":"http://baozhacao.github.io/tags/Map/"}]},{"title":"js函数中this指向问题","slug":"js函数中this指向","date":"2023-01-21T05:00:47.000Z","updated":"2023-02-19T04:18:40.388Z","comments":true,"path":"2023/01/21/js-han-shu-zhong-this-zhi-xiang/","link":"","permalink":"http://baozhacao.github.io/2023/01/21/js-han-shu-zhong-this-zhi-xiang/","excerpt":"","text":"1.为什么要有this 在常见的编程语言中，几乎都有this这个关键字（Objective-C中使用的是self），但是JavaScript中的this和常见的面向对象语言中的this不太一样： 常见面向对象的编程语言中，比如Java、C++、Swift、Dart等等一系列语言中，this通常只会出现在类的方法中。 也就是你需要有一个类，类中的方法（特别是实例方法）中，this代表的是当前调用对象。 但是JavaScript中的this更加灵活，无论是它出现的位置还是它代表的含义。 2.this的绑定规则this的绑定和定义的位置（编写的位置）没有关系； this的绑定和调用方式以及调用的位置有关系； 绑定一：默认绑定； 独立的函数调用，我们可以理解成函数没有被绑定到某个对象上进行调用；（this指向window） // 1.案例一: function foo() &#123; console.log(this) &#125; foo()//window // 2.案例二: function foo1() &#123; console.log(this) &#125; function foo2() &#123; console.log(this) foo1() &#125; function foo3() &#123; console.log(this) foo2() &#125; foo3()//window window window // 3.案例三: var obj = &#123; name: \"why\", foo: function() &#123; console.log(this) &#125; &#125; var bar = obj.foo bar() // window // 4.案例四: function foo() &#123; console.log(this) &#125; var obj = &#123; name: \"why\", foo: foo &#125; var bar = obj.foo bar() // window 绑定二：隐式绑定； 也就是它的调用位置中，是通过某个对象发起的函数调用(谁调用this指向谁) //1.案例一: var obj = &#123; name: \"why\", foo: foo &#125; obj.foo() // obj对象 //2.案例二: var obj = &#123; name: \"why\", eating: function() &#123; console.log(this.name + \"在吃东西\") &#125;, running: function() &#123; console.log(obj.name + \"在跑步\") &#125; &#125; // obj.eating() // obj.running() var fn = obj.eating fn() // 3.案例三: var obj1 = &#123; name: \"obj1\", foo: function() &#123; console.log(this) &#125; &#125; var obj2 = &#123; name: \"obj2\", bar: obj1.foo &#125; obj2.bar() 绑定三：显示绑定； 必须在调用的对象内部有一个对函数的引用（比如一个属性）； 如果没有这样的引用，在进行调用时，会报找不到该函数的错误； 正是通过这个引用，间接的将this绑定到了这个对象上 // 1.foo直接调用和call/apply调用的不同在于this绑定的不同 // foo直接调用指向的是全局对象(window) // foo() var obj = &#123; name: \"obj\" &#125; // call/apply是可以指定this的绑定对象 foo.call(obj) foo.apply(obj) foo.apply(\"aaaa\") // 2.call和apply有什么区别? function sum(num1, num2, num3) &#123; console.log(num1 + num2 + num3, this) &#125; sum.call(\"call\", 20, 30, 40) sum.apply(\"apply\", [20, 30, 40]) // 3.call和apply在执行函数时,是可以明确的绑定this, 这个绑定规则称之为显示绑定 优先级：显示 &gt; 隐式 &gt; 默认 3.this绑定规则之外 忽略显示绑定 如果在显示绑定中，我们传入一个null或者undefined，那么这个显示绑定会被忽略，使用默认规则 foo.call(obj)//obj对象 foo.call(null);//window foo.call(undefined);//window 间接函数引用 创建一个函数的 间接引用，这种情况使用默认绑定规则。 obj2.foo = obj1.foo //window ES6箭头函数 因为箭头函数并不绑定this对象，那么this引用就会从上层作用于中找到对应的this 4.经典面试题 var name = \"window\"; var person = &#123; name: \"person\", sayName: function () &#123; console.log(this.name); &#125; &#125;; function sayName() &#123; var sss = person.sayName; sss(); // window: 独立函数调用 person.sayName(); // person: 隐式调用 (person.sayName)(); // person: 隐式调用 (b = person.sayName)(); // window: 赋值表达式(独立函数调用) &#125; sayName(); var name = 'window' var person1 = &#123; name: 'person1', foo1: function () &#123; console.log(this.name) &#125;, foo2: () => console.log(this.name), foo3: function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, foo4: function () &#123; return () => &#123; console.log(this.name) &#125; &#125; &#125; var person2 = &#123; name: 'person2' &#125; // person1.foo1(); // person1(隐式绑定) // person1.foo1.call(person2); // person2(显示绑定优先级大于隐式绑定) // person1.foo2(); // window(不绑定作用域,上层作用域是全局) // person1.foo2.call(person2); // window // person1.foo3()(); // window(独立函数调用) // person1.foo3.call(person2)(); // window(独立函数调用) // person1.foo3().call(person2); // person2(最终调用返回函数式, 使用的是显示绑定) // person1.foo4()(); // person1(箭头函数不绑定this, 上层作用域this是person1) // person1.foo4.call(person2)(); // person2(上层作用域被显示的绑定了一个person2) // person1.foo4().call(person2); // person1(上层找到person1) var name = 'window' function Person (name) &#123; this.name = name this.foo1 = function () &#123; console.log(this.name) &#125;, this.foo2 = () => console.log(this.name), this.foo3 = function () &#123; return function () &#123; console.log(this.name) &#125; &#125;, this.foo4 = function () &#123; return () => &#123; console.log(this.name) &#125; &#125; &#125; var person1 = new Person('person1') var person2 = new Person('person2') person1.foo1() // person1 person1.foo1.call(person2) // person2(显示高于隐式绑定) person1.foo2() // person1 (上层作用域中的this是person1) person1.foo2.call(person2) // person1 (上层作用域中的this是person1) person1.foo3()() // window(独立函数调用) person1.foo3.call(person2)() // window person1.foo3().call(person2) // person2 person1.foo4()() // person1 person1.foo4.call(person2)() // person2 person1.foo4().call(person2) // person1 var obj = &#123; name: \"obj\", foo: function() &#123; &#125; &#125; var name = 'window' function Person (name) &amp;#123; this.name = name this.obj = &amp;#123; name: 'obj', foo1: function () &amp;#123; return function () &amp;#123; console.log(this.name) &amp;#125; &amp;#125;, foo2: function () &amp;#123; return () => &amp;#123; console.log(this.name) &amp;#125; &amp;#125; &amp;#125; &amp;#125; var person1 = new Person('person1') var person2 = new Person('person2') person1.obj.foo1()() // window person1.obj.foo1.call(person2)() // window person1.obj.foo1().call(person2) // person2 person1.obj.foo2()() // obj person1.obj.foo2.call(person2)() // person2 person1.obj.foo2().call(person2) // obj","categories":[{"name":"js高级","slug":"js高级","permalink":"http://baozhacao.github.io/categories/js%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"js","slug":"js","permalink":"http://baozhacao.github.io/tags/js/"},{"name":"this","slug":"this","permalink":"http://baozhacao.github.io/tags/this/"}]},{"title":"js实现Promise","slug":"js实现Promise","date":"2022-12-28T06:15:49.000Z","updated":"2023-02-19T04:19:29.754Z","comments":true,"path":"2022/12/28/js-shi-xian-promise/","link":"","permalink":"http://baozhacao.github.io/2022/12/28/js-shi-xian-promise/","excerpt":"","text":"1. 什么是Promise 异步和同步 异步，操作之间没有关系，同时执行多个操作， 代码复杂 同步，同时只能做一件事，代码简单 Promise是一个类，可以翻译成 承诺、许诺 、期约； 用同步的方式来书写异步代码; 在通过new创建Promise对象时，我们需要传入一个回调函数，我们称之为executor 这个回调函数会被立即执行，并且给传入另外两个回调函数resolve、reject； 当我们调用resolve回调函数时，会执行Promise对象的then方法传入的回调函数； 当我们调用reject回调函数时，会执行Promise对象的catch方法传入的回调函数； 2. Promise常用方法 Promise 实例有一个thenthen、catch、finally方法 function f1(resolve, reject) &#123; // 异步代码... &#125; var p1 = new Promise(f1); p1.then(res=>&#123; //用来指定下一步的回调函数 &#125;).catch(err=>&#123; //收集错误 &#125;).finally(()=>&#123; //无论什么时候都会执行 &#125;); // f1的异步操作执行完成，就会执行f2。 有时候我们已经有一个现成的内容了，希望将其转成Promise来使用，这个时候我们可以使用 Promise.resolve 方法来完成。 Promise.resolve的用法相当于new Promise，并且执行resolve操作： resolve参数的形态： 情况一：参数是一个普通的值或者对象 情况二：参数本身是Promise 情况三：参数是一个thenable Promise.all(promiseArray)方法 将多个Promise对象实例包装，生成并返回一个新的Promise实例 promise数组中所有的promise实例都变为resolve的时候，该方法才会返回 并将所有结果传递results数组中 promise数组中任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的promise对象 reject方法类似于resolve方法，只是会将Promise对象的状态设置为reject状态。 var p1 = Promise.resolve(1), p2 = Promise.resolve(2), p3 = Promise.resolve(3); Promise.all([p1, p2, p3]).then(function (results) &#123; console.log(results); // [1, 2, 3] &#125;); Promise.race([p1, p2, p3]) Promse.race就是赛跑的意思 哪个结果获得的快，就返回那个结果 不管结果本身是成功状态还是失败状态 3. js实现Promise// 手写promise // 实现规范https://promisesaplus.com/ //创建promise的执行状态 const PROMISE_STATUS_PENDING = 'pending' const PROMISE_STATUS_FULFILLED = 'fulfilled' const PROMISE_STATUS_REJECTED = 'rejected' // 工具函数 function execFunctionWithCatchError(execFn, value, resolve, reject) &#123; try &#123; const result = execFn(value) resolve(result) &#125; catch (err) &#123; reject(err) &#125; &#125; class HYPromise &#123; constructor(executor) &#123; this.status = PROMISE_STATUS_PENDING this.value = undefined this.reason = undefined //定义两个数组，放res，err，解决连续调用后面一个覆盖前面一个的 // 问题，放到数组里循环遍历执行每一个函数 this.onFulfilledFns = [] this.onRejectedFns = [] const resolve = (value) => &#123; if (this.status === PROMISE_STATUS_PENDING) &#123; //把这个函数放到微任务里，也可以用setTimeout，把任务放到宏任务里 //原因是要让调用的then先执行 queueMicrotask(() => &#123; this.status = PROMISE_STATUS_FULFILLED this.value = value this.onFulfilledFns.forEach(fn => &#123; fn(this.value) &#125;) &#125;) &#125; &#125; const reject = (reason) => &#123; if (this.status === PROMISE_STATUS_PENDING) &#123; queueMicrotask(() => &#123; if (this.status !== PROMISE_STATUS_PENDING) return this.status = PROMISE_STATUS_REJECTED this.reason = reason this.onRejectedFns.forEach(fn => &#123; fn(this.reason) &#125;) &#125;) &#125; &#125; //传入的函数，立即调用 try &#123; executor(resolve, reject) &#125; catch (err) &#123; reject(err) &#125; &#125; then(onFulfilled, onRejected) &#123; // catch解决方法,抛出异常之后err会传给下一个promise执行 const defaultOnRejected = err => &#123; throw err &#125; onRejected = onRejected || defaultOnRejected //链式调用的解决方法 return new HYPromise((resolve, reject) => &#123; // 1.如果在then调用的时候, 状态已经确定下来 // 解决前面调用过之后，后面又用定时器延迟调用的问题 if (this.status === PROMISE_STATUS_FULFILLED &amp;&amp; onFulfilled) &#123; // try &#123; // const value = onFulfilled(this.value) // resolve(value) // &#125; catch(err) &#123; // reject(err) // &#125; execFunctionWithCatchError(onFulfilled, this.value, resolve, reject) &#125; if (this.status === PROMISE_STATUS_REJECTED &amp;&amp; onRejected) &#123; // try &#123; // const reason = onRejected(this.reason) // resolve(reason) // &#125; catch(err) &#123; // reject(err) // &#125; execFunctionWithCatchError(onRejected, this.reason, resolve, reject) &#125; // 2.将成功回调和失败的回调放到数组中 if (this.status === PROMISE_STATUS_PENDING) &#123; if (onFulfilled) this.onFulfilledFns.push(() => &#123; // try &#123; // const value = onFulfilled(this.value) // resolve(value) // &#125; catch(err) &#123; // reject(err) // &#125; execFunctionWithCatchError(onFulfilled, this.value, resolve, reject) &#125;) if (onRejected) this.onRejectedFns.push(() => &#123; // try &#123; // const reason = onRejected(this.reason) // resolve(reason) // &#125; catch(err) &#123; // reject(err) // &#125; execFunctionWithCatchError(onRejected, this.reason, resolve, reject) &#125;) &#125; &#125;) &#125; catch (onRejected) &#123; //return出一个promise return this.then(undefined, onRejected) &#125; //无论成功或失败都要调用这个函数 finally(onFinally) &#123; this.then(() => &#123; onFinally() &#125;, () => &#123; onFinally() &#125;) &#125; // 静态方法的实现 static resolve(value) &#123; return new HYPromise((resolve) => resolve(value)) &#125; static reject(reason) &#123; return new HYPromise((resolve, reject) => reject(reason)) &#125; static all(promises) &#123; // 问题关键: 什么时候要执行resolve, 什么时候要执行reject return new HYPromise((resolve, reject) => &#123; const values = [] promises.forEach(promise => &#123; promise.then(res => &#123; values.push(res) if (values.length === promises.length) &#123; resolve(values) &#125; &#125;, err => &#123; reject(err) &#125;) &#125;) &#125;) &#125; static allSettled(promises) &#123; return new HYPromise((resolve) => &#123; const results = [] promises.forEach(promise => &#123; promise.then(res => &#123; results.push(&#123; status: PROMISE_STATUS_FULFILLED, value: res&#125;) if (results.length === promises.length) &#123; resolve(results) &#125; &#125;, err => &#123; results.push(&#123; status: PROMISE_STATUS_REJECTED, value: err&#125;) if (results.length === promises.length) &#123; resolve(results) &#125; &#125;) &#125;) &#125;) &#125; static race(promises) &#123; return new HYPromise((resolve, reject) => &#123; promises.forEach(promise => &#123; // promise.then(res => &#123; // resolve(res) // &#125;, err => &#123; // reject(err) // &#125;) promise.then(resolve, reject) &#125;) &#125;) &#125; static any(promises) &#123; // resolve必须等到有一个成功的结果 // reject所有的都失败才执行reject const reasons = [] return new HYPromise((resolve, reject) => &#123; promises.forEach(promise => &#123; promise.then(resolve, err => &#123; reasons.push(err) if (reasons.length === promises.length) &#123; reject(new AggregateError(reasons)) &#125; &#125;) &#125;) &#125;) &#125; &#125; //调用 const promise = new HYPromise((resolve, reject) => &#123; console.log(\"状态padding\"); //reject(222),这两个只能调用一个，其他的无效 resolve(111) // throw new Error(\"executor error message\") &#125;) // 调用then方法 promise.then(res => &#123; console.log(\"res1\", res); &#125;, err => &#123; console.log(\"err1\", err); &#125;) // 调用多次then promise.then(res => &#123; console.log(\"res2:\", res) &#125;, err => &#123; console.log(\"err2:\", err) &#125;) // 在确定Promise状态之后, 再次调用then setTimeout(() => &#123; promise.then(res => &#123; console.log(\"res3:\", res) &#125;, err => &#123; console.log(\"err3:\", err) &#125;) &#125;, 1000) //链式调用 promise.then(res => &#123; console.log(\"res1:\", res) return \"aaaa\" // throw new Error(\"err message\") &#125;, err => &#123; console.log(\"err1:\", err) return \"bbbbb\" // throw new Error(\"err message\") &#125;).then(res => &#123; console.log(\"res2:\", res) &#125;, err => &#123; console.log(\"err2:\", err) &#125;) //catch promise.then(res => &#123; console.log(\"res:\", res) &#125;).catch(err => &#123; console.log(\"err:\", err) &#125;)","categories":[{"name":"js高级","slug":"js高级","permalink":"http://baozhacao.github.io/categories/js%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"js","slug":"js","permalink":"http://baozhacao.github.io/tags/js/"},{"name":"Promise","slug":"Promise","permalink":"http://baozhacao.github.io/tags/Promise/"}]},{"title":"es6+之Proxy-Reflect","slug":"es6-之Proxy-Reflect","date":"2022-12-25T05:51:49.000Z","updated":"2023-02-19T04:18:14.898Z","comments":true,"path":"2022/12/25/es6-zhi-proxy-reflect/","link":"","permalink":"http://baozhacao.github.io/2022/12/25/es6-zhi-proxy-reflect/","excerpt":"","text":"1.前言 在开始Proxy和Reflect之前我们先说一Object.definePropert 在前面我们的属性都是直接定义在对象内部，或者直接添加到对象内部的，但是这样来做的时候我们就不能对这个属性进行一些限制，比如任何时候都可以删除或遍历操作。 如果我们想要对一个属性进行比较精准的操作控制，那么我们就可以使用属性描述符。 通过属性描述符Object.definePropert可以精准的添加或修改对象的属性； Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。 Object.defineProperty(obj,prop,descriptor) - obj：要定义属性的对象； - prop：要定义或修改的属性的名称或 Symbol； - descriptor：要定义或修改的属性描述符； - 返回值： 被传递给函数的对象。 属性描述符的类型有两种： 数据属性； 存取属性； //数据属性 / name和age虽然没有使用属性描述符来定义, 但是它们也是具备对应的特性的 // value: 赋值的value // configurable: true // enumerable: true // writable: true var obj = &#123; name: \"why\", age: 18 &#125; // 数据属性描述符 // 用了属性描述符, 那么会有默认的特性 Object.defineProperty(obj, \"address\", &#123; value: \"北京市\", // 默认值undefined configurable: false, // 默认值false,该特殊不可删除/也不可以重新定义属性描述符 enumerable: true, // 默认值false,该特殊是配置对应的属性(address)是否是可以枚举 writable: false // 默认值false,该特性是属性是否是可以赋值(写入值) &#125;) //存取属性 var obj = &#123; name: \"why\", age: 18, _address: \"北京市\" &#125; // 存取属性描述符 // 1.隐藏某一个私有属性被希望直接被外界使用和赋值 // 2.如果我们希望截获某一个属性它访问和设置值的过程时, 也会使用存储属性描述符 Object.defineProperty(obj, \"address\", &#123; enumerable: true, configurable: true, get: function() &#123; foo() return this._address &#125;, set: function(value) &#123; bar() this._address = value &#125; &#125;) 如上是用Object.defineProperty 的存储属性描述符来对 属性的操作进行监听。但是这样做有什么缺点呢？ 首先，Object.defineProperty设计的初衷，不是为了去监听截止一个对象中 所有的属性的。 ü 我们在定义某些属性的时候，初衷其实是定义普通的属性，但是后面我们强 行将它变成了数据属性描述符。 p 其次，如果我们想监听更加丰富的操作，比如新增属性、删除属性，那么 Object.defineProperty是无能为力的。 2. Proxy基本使用 在ES6中，新增了一个Proxy类，这个类从名字就可以看出来，是用于帮助我们创建一个代理的： 也就是说，如果我们希望监听一个对象的相关操作，那么我们可以先创建一个代理对象（Proxy对象）； 之后对该对象的所有操作，都通过代理对象来完成，代理对象可以监听我们想要对原对象进行哪些操作； const obj = &#123; name:\"why\", age:18 &#125; const objProxy = new Proxy(obj,&#123;&#125;)// 第一个参数为所代理的对象，第二个参数为捕获器，就是对代理的对像做操作，常用的有set和get set和get分别对应的是函数类型 set函数有四个参数： target：目标对象（侦听的对象）； property：将被设置的属性key； value：新属性值； receiver：调用的代理对象； get函数有三个参数： target：目标对象（侦听的对象）； property：将被设置的属性key； receiver：调用的代理对象； const obj = &#123; name: \"why\", age: 18 &#125; const objProxy = new Proxy(obj, &#123; // 获取值时的捕获器 get: function(target, key) &#123; console.log(`监听到对象的$&#123;key&#125;属性被访问了`, target) return target[key] &#125;, // 设置值时的捕获器 set: function(target, key, newValue) &#123; console.log(`监听到对象的$&#123;key&#125;属性被设置值`, target) target[key] = newValue &#125;, // 监听in的捕获器 has: function(target, key) &#123; console.log(`监听到对象的$&#123;key&#125;属性in操作`, target) return key in target &#125;, // 监听delete的捕获器 deleteProperty: function(target, key) &#123; console.log(`监听到对象的$&#123;key&#125;属性in操作`, target) delete target[key] &#125; &#125;) //对函数对象的捕获 function foo() &#123; &#125; const fooProxy = new Proxy(foo, &#123; apply: function(target, thisArg, argArray) &#123; console.log(\"对foo函数进行了apply调用\") return target.apply(thisArg, argArray) &#125;, construct: function(target, argArray, newTarget) &#123; console.log(\"对foo函数进行了new调用\") return new target(...argArray) &#125; &#125;) fooProxy.apply(&#123;&#125;, [\"abc\", \"cba\"]) new fooProxy(\"abc\", \"cba\") 3. Reflect的作用 Reflect也是ES6新增的一个API，它是一个对象，字面的意思是反射。 它主要提供了很多操作JavaScript对象的方法，有点像Object中操作对象的方法； //比如Reflect.getPrototypeOf(target)类似于 Object.getPrototypeOf()； //比如Reflect.defineProperty(target, propertyKey, attributes)类似于Object.defineProperty() 如果我们有Object可以做这些操作，那么为什么还需要有Reflect这样的新增对象呢 这是因为在早期的ECMA规范中没有考虑到这种对 对象本身 的操作如何设计会更加规范，所以将这些API放到了Object上面； 但是Object作为一个构造函数，这些操作实际上放到它身上并不合适； 另外还包含一些类似于 in、delete操作符，让JS看起来是会有一些奇怪的； 所以在ES6中新增了Reflect，让我们这些操作都集中到了Reflect对象上； const obj = &#123; _name: \"why\", get name() &#123; return this._name &#125;, set name(newValue) &#123; this._name = newValue &#125; &#125; const objProxy = new Proxy(obj, &#123; get: function(target, key, receiver) &#123; // receiver是创建出来的代理对象 console.log(\"get方法被访问--------\", key, receiver) console.log(receiver === objProxy) return Reflect.get(target, key, receiver) &#125;, set: function(target, key, newValue, receiver) &#123; console.log(\"set方法被访问--------\", key) Reflect.set(target, key, newValue, receiver) &#125; &#125;) // console.log(objProxy.name) objProxy.name = \"kobe\" 我们发现在使用getter、setter的时候有一个receiver的参数，它的作用是什么呢？如果我们的源对象（obj）有setter、getter的访问器属性，那么可以通过receiver来改变里面的this； const obj = &#123; _name: \"why\", get name() &#123; return this._name &#125;, set name(newValue) &#123; this._name = newValue &#125; &#125; const objProxy = new Proxy(obj, &#123; get: function(target, key, receiver) &#123; // receiver是创建出来的代理对象 console.log(\"get方法被访问--------\", key, receiver) console.log(receiver === objProxy) return Reflect.get(target, key, receiver) &#125;, set: function(target, key, newValue, receiver) &#123; console.log(\"set方法被访问--------\", key) Reflect.set(target, key, newValue, receiver) &#125; &#125;) // console.log(objProxy.name) objProxy.name = \"kobe\" Reflect的construct function Student(name, age) &#123; this.name = name this.age = age &#125; function Teacher() &#123; &#125; // const stu = new Student(\"why\", 18) // console.log(stu) // console.log(stu.__proto__ === Student.prototype) // 执行Student函数中的内容, 但是创建出来对象是Teacher对象 const teacher = Reflect.construct(Student, [\"why\", 18], Teacher) console.log(teacher) console.log(teacher.__proto__ === Teacher.prototype) 4. 例子敬请期待！","categories":[{"name":"es6","slug":"es6","permalink":"http://baozhacao.github.io/categories/es6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://baozhacao.github.io/tags/es6/"},{"name":"definePropert","slug":"definePropert","permalink":"http://baozhacao.github.io/tags/definePropert/"},{"name":"Proxy","slug":"Proxy","permalink":"http://baozhacao.github.io/tags/Proxy/"},{"name":"Reflect","slug":"Reflect","permalink":"http://baozhacao.github.io/tags/Reflect/"}]},{"title":"js强引用和弱引用","slug":"js强引用和弱引用","date":"2022-12-02T04:36:22.000Z","updated":"2023-02-19T04:18:58.170Z","comments":true,"path":"2022/12/02/js-qiang-yin-yong-he-ruo-yin-yong/","link":"","permalink":"http://baozhacao.github.io/2022/12/02/js-qiang-yin-yong-he-ruo-yin-yong/","excerpt":"","text":"1.前言 在JavaScript 中，开发者不需要手动进行内存管理，JS 引擎会“自动”做这些事情。JavaScript在创建变量时自动进行了分配内存，并且在不使用它们时“自动”释放。这个释放的过程叫做垃圾回收。但是虽然说是“自动”释放，但这并不意味着我们开发者就不用关心内存管理问题。 2.强引用 强引用是使用最普遍的引用。它是指向内存申请一段存储空间，进行存储的引用类型的对象的引用。在对象获得的分配内存空间中不仅仅存放了对象的信息，还存放着该对象被引用的次数。 如果一个对象具有强引用，那么垃圾回收器就不会回收它。 3.弱引用 一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。但是，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快地发现那些只具有弱引用的对象。 也就是说，一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收。 4.例子 weakSet和weakMap","categories":[{"name":"js高级","slug":"js高级","permalink":"http://baozhacao.github.io/categories/js%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"js","slug":"js","permalink":"http://baozhacao.github.io/tags/js/"},{"name":"强引","slug":"强引","permalink":"http://baozhacao.github.io/tags/%E5%BC%BA%E5%BC%95/"},{"name":"弱引","slug":"弱引","permalink":"http://baozhacao.github.io/tags/%E5%BC%B1%E5%BC%95/"}]},{"title":"es6语法","slug":"es6基础语法","date":"2022-11-22T05:05:47.000Z","updated":"2023-02-19T04:18:00.124Z","comments":true,"path":"2022/11/22/es6-ji-chu-yu-fa/","link":"","permalink":"http://baozhacao.github.io/2022/11/22/es6-ji-chu-yu-fa/","excerpt":"","text":"1.ES6怎么来的 ECMAScript和JavaScript ECMA是标准，JS是实现 ECMAScript简称ECMA或ES 历史版本 1996年，ES1.0 Netscape将JS提交给ECMA组织，ES正式出现 1999年，ES3.0被广泛支持 2011，ES5.1成为ISO国际标准 2015年，ES6.0正式发布 2.ES6兼容性 ES6（ES2015）支持的环境IE10 +，Chrome，FireFox，移动端，NodeJS 解决不兼容办法，编译，转换 在线转换 或者提前编译 Babel中文网 Babel入门教程阮一峰 Babel是一个JavaScript编译器 一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境中执行 现在就用ES6编写程序，而不用担心现有环境是否支持 3.let-const-var let关键字 从直观的角度来说，let和var是没有太大的区别的，都是用于声明一个变量； const关键字 const关键字是constant的单词的缩写，表示常量、衡量的意思； 它表示保存的数据一旦被赋值，就不能被修改； 但是如果赋值的是引用类型，那么可以通过引用找到对应的对象，修改对象的内容 注意：另外let、const不允许重复声明变量； 使用场景var所表现出来的特殊性：比如作用域提升、window全局对象、没有块级作用域等都是一些 历史遗留问题；其实是JavaScript在设计之初的一种语言缺陷； 对于let和const来说，是目前开发中推荐使用的；会优先推荐使用const，这样可以保证数据的安全性不会被随意的篡改； 只有当我们明确知道一个变量后续会需要被重新赋值时，这个时候再使用let；这种在很多其他语言里面也都是一种约定俗成的规范，尽量我们也遵守这种规范； 特点let关键字 不允许重复声明； 块儿级作用域（局部变量）； 不存在变量提升； 不影响作用域链； const关键字 声明必须赋初始值； 不允许重复声明； 值不允许修改； 块儿级作用域（局部变量）； // 1. 不允许重复声明； let dog = \"狗\"; let dog = \"狗\"; // 报错：Uncaught SyntaxError: Identifier 'dog' has already been declared // 2. 块儿级作用域（局部变量）； &#123; let cat = \"猫\"; console.log(cat); &#125; console.log(cat); // 报错：Uncaught ReferenceError: cat is not defined // 3. 不存在变量提升； // 什么是变量提升：就是在变量创建之前使用（比如输出：输出的是默认值），let不存在，var存在； console.log(people1); // 可输出默认值 console.log(people2); // 报错：Uncaught ReferenceError: people2 is not defined var people1 = \"大哥\"; // 存在变量提升 let people2 = \"二哥\"; // 不存在变量提升 // 4. 不影响作用域链； // 什么是作用域链：很简单，就是代码块内有代码块，跟常规编程语言一样，上级代码块中 的局部变量下级可用 &#123; let p = \"大哥\"; function fn()&#123; console.log(p); // 这里是可以使用的 &#125; fn(); &#125; 4.对象字面量增强的写法const name = \"why\"; const age = 18; const obj = &#123; //对属性 name, age, // 对方法 foo()&#123;console.log(lll)&#125;, // 计算属性名 [name+123]:'hahaha' &#125; 5.解构赋值使用场景：1.在开发中拿到一个变量时，自动对其解构使用2.在函数传参传入一个对象或数组时，可直接对其解构使用 const names = ['aaa','bbb','ccc']; // 对数组的解构 const [item1,item2,item3] = names; // 只结构后面的元素 const [,,item1] = names; // 解构出一个元素后面的元素放到新的数组中 const [item1,...newNames] = names; const obj = &#123; name:\"why\", age:18, height:1.88 &#125; // 对对象的解构 &#123;&#125; const &#123;name,age,height&#125; = obj // 对结构的名字重命名 const &#123;name:newName&#125; = obj //newName:\"why\" 6.模板字符串使用场景：当遇到字符串与变量拼接的情况使用模板字符串； // 特性 // 1、字符串中可以出现换行符 let str = `&lt;ul> &lt;li>大哥&lt;/li> &lt;/ul>`; // 2、可以使用 $&#123;xxx&#125; 形式引用变量 let s = \"大哥\"; let out = `$&#123;s&#125;是我最大的榜样！`; 7.扩展运算符… 扩展运算符能将数组转换为逗号分隔的参数序列； //1. 数组的合并 情圣 误杀 唐探 const kuaizi = ['王太利','肖央']; const fenghuang = ['曾毅','玲花']; const zuixuanxiaopingguo = [...kuaizi, ...fenghuang]; //2. 数组的克隆 const sanzhihua = ['E','G','M']; const sanyecao = [...sanzhihua];// ['E','G','M'] //3. 将伪数组转为真正的数组 const divs = document.querySelectorAll('div'); const divArr = [...divs]; 8.箭头函数 箭头函数，就是函数的简写 如果只有一个参数，()可以省 如果只有一个return，&#123;&#125;可以省 注意点 箭头函数的this是静态的，始终指向函数声明时所在作用域下的this的值；(就是上层作用域的值) 不能作为构造实例化对象； 不能使用 arguments 变量； //无参数 let speak = () => console.log(\"hello 哈哈！\"); //一个参数 let hi = name => \"hi \" + name //多个参数 let he = (a,b,c) => a + b + c; //this的指向 getName1 = () => console.log(\"getName1：\" + this);//this指向window 9.数组 新增4个方法 map 映射 一个对一个 let arr &#x3D; [12, 5, 8] let result &#x3D; arr.map(function (item) &#123; return item*2 &#125;) let result2 &#x3D; arr.map(item&#x3D;&gt;item*2) &#x2F;&#x2F; 简写 console.log(result) console.log(result2) let score &#x3D; [18, 86, 88, 24] let result3 &#x3D; score.map(item &#x3D;&gt; item &gt;&#x3D; 60 ? &#39;及格&#39; : &#39;不及格&#39;) console.log(result3) &#x2F;&#x2F; 结果 [ 24, 10, 16 ] [ 24, 10, 16 ] [ &#39;不及格&#39;, &#39;及格&#39;, &#39;及格&#39;, &#39;不及格&#39; ] reduce 汇总 一堆出来一个 用于比如，算个总数，算个平均 var arr &#x3D; [1, 3, 5, 7] var result &#x3D; arr.reduce(function (tmp, item, index) &#123; &#x2F;&#x2F;tmp 上次结果，item当前数，index次数1开始 console.log(tmp, item, index) return tmp + item &#125;) console.log(result) var arr &#x3D; [1, 3, 5, 7] var result &#x3D; arr.reduce(function (tmp, item, index) &#123; if (index !&#x3D; arr.length - 1) &#123; &#x2F;&#x2F; 不是最后一次 return tmp + item &#125; else &#123; return (tmp + item)&#x2F;arr.length &#125; &#125;) console.log(result) &#x2F;&#x2F; 平均值 filter 过滤器 保留为true的 var arr &#x3D; [12, 4, 8, 9] var result &#x3D; arr.filter(item &#x3D;&gt; (item % 3 &#x3D;&#x3D;&#x3D; 0) ? true : false) console.log(result) var result &#x3D; arr.filter(item &#x3D;&gt; item % 3 &#x3D;&#x3D;&#x3D; 0) console.log(result) var arr &#x3D; [ &#123; title: &#39;苹果&#39;, price: 10 &#125;, &#123; title: &#39;西瓜&#39;, price: 20 &#125;, ] var result &#x3D; arr.filter(json &#x3D;&gt; json.price &gt;&#x3D; 20) console.log(result) forEach 循环迭代 var arr &#x3D; [12, 4, 8, 9] var result &#x3D; arr.forEach(item &#x3D;&gt; console.log(item)) var result &#x3D; arr.forEach((item, index)&#x3D;&gt;console.log(item, index)) 10.Symbol Symbol 的值是唯一的，用来解决命名冲突的问题； Symbol 值不能与其他数据进行运算； Symbol 定义的对象属性不能使用for…in循环遍历 ，但是可以使用Reflect.ownKeys 来获取对象的 所有键名； //创建Symbol let s = Symbol(); // 向对象中添加方法 // 方式一 let methods = &#123; up: Symbol(), down: Symbol() &#125;; game[methods.up] = function()&#123; console.log(\"我可以改变形状\"); &#125; game[methods.down] = function()&#123; Symbol内置值： 概述： 除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方 法。可以称这些方法为魔术方法，因为它们会在特定的场景下自动执行； 方法： console.log(\"我可以快速下降!!\"); &#125; console.log(game); // 方式二 let youxi = &#123; name:\"狼人杀\", [Symbol('say')]: function()&#123; console.log(\"我可以发言\") &#125;, [Symbol('zibao')]: function()&#123; console.log('我可以自爆'); &#125; &#125; console.log(youxi);","categories":[{"name":"es6","slug":"es6","permalink":"http://baozhacao.github.io/categories/es6/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://baozhacao.github.io/tags/es6/"}]},{"title":"Vue面试题1","slug":"vue原理层","date":"2022-11-13T09:15:49.000Z","updated":"2023-02-19T04:20:14.417Z","comments":true,"path":"2022/11/13/vue-yuan-li-ceng/","link":"","permalink":"http://baozhacao.github.io/2022/11/13/vue-yuan-li-ceng/","excerpt":"","text":"1. 虚拟dom1. 虚拟dom是什么？ 在vue2.x版本中才加入虚拟dom 虚拟dom的本质就是一个js对象 具有跨平台的特性，在各个端都可以运行。 2. 虚拟dom在vue中做了什么 vue的渲染过程(最终会渲染成HTML,css,js) 如图所示，虚拟dom的两条线—-初始化和更新 第一条是将真实dom转化为虚拟dom 比较累赘 第二条线是更新的时候用来做对比 3. 虚拟dom如何提升vue的渲染效率 vue的两大核心 组件化和数据驱动 a.局部更新（更新节点数据，不需要摧毁整个元素） b.将直接操作dom拿到js对象中作比较 2. Diff算法中的patch()vue渲染的两条线的实现 1.初始化patch(container,vnode) function createElement(vnode)&#123; // 虚拟dom生成的三个要素 let tag = vnode.tag //目标元素 不可或缺 let attrs = vnode.attrs || &#123;&#125; //属性 let children = vnode.children || [] //子节点 if (!tag) &#123; return null &#125; let elem = document.createElement(tag) let attrName //节点里的属性 for(attrName in attrs)&#123; if (attrs.hasOwnProperty(attrName)) &#123; elem.setAttribute(attrName,attrs[attrName]) &#125; &#125; //将子元素添加到目标元素之上 children.forEach(childVnode => &#123; elem.appendChild(createElement(childVnode))//如果还有子元素，则通过递归继续添加 &#125;); return elem &#125; 2.更新patch(vnode,newVnode),更新子节点，不需要全部更新 function updataChildren(vnode,newVnode)&#123; //拿到新旧虚拟dom的子节点 let vnode = vnode.children || [] let newVnode = newVnode.children || [] //遍历对比更新 children.forEach((childrenVnode,index)=>&#123; //循环的每一项,拿到新的节点的每一项和老的进行对比 let newChildrenVnode = newChildren[index] //证明第一层没有变化 if (childrenVnode.tag == newChildrenVnode.tag) &#123; updataChildren(childrenVnode,newChildrenVnode)//第一层没变化使用递归继续对比 &#125;else&#123; replaceNode(childrenVnode,newChildrenVnode)//vue内部方法，新老节点进行替换 &#125; &#125;) &#125; 3. Vue2.x响应式原理 通过发布订阅模式和数据劫持(Object.defineProperty)实现。 //订阅器模型 let Dep = &#123; clientList: &#123;&#125;,//一个容器，用来存放用户的各种数据 //添加订阅 listen: function (key, fn) &#123; //判断一个人有没有登记过 // if (!this.clientList[key]) &#123; // this.clientList[key] = [] // &#125; // this.clientList[key].push(fn) //简化，短路表达式 (this.clientList[key] || (this.clientList[key] = [])).push(fn) &#125;, // 发布订阅，数据变化时提醒 trigger: function () &#123; let key = Array.prototype.shift.call(arguments),//将类数组转化为数组 fns = this.clientList[key]//拿到当前这一项 if (!fns || fns.length === 0) &#123; return false; &#125; for (let i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments) &#125; &#125; &#125; //数据劫持的方法 let dataHi = function (&#123; data, tag, dataKey, selector &#125;) &#123; let value = '', el = document.querySelector(selector) Object.defineProperty(data, dataKey, &#123; //取值 get: function () &#123; console.log(\"取值\"); return value &#125; set: function (val) &#123; value = val; //发布 Dep.trigger(tag, val) &#125; &#125;) //给这个对象添加订阅，要订阅了，才能发布 Dep.listen(tag, function (text) &#123; el.innerHTML = text &#125;) &#125; 响应式 数据联动（双向绑定） 捕获修改 4. Vue3.x响应式原理// 1. Object.defineProperty => Proxy() // Vue2.x data中的属性做了遍历 + 递归, 给每一个属性设置getter, setter // data中预定义属性做出响应式 // 2. Proxy() // 2.1 监听是针对一整个对象(完全代理所有属性) // 2.2 在目标对象之前假设一层拦截 => 外界访问该对象，必须通过这层拦截 // 响应式重要特征 => 需要捕获到修改，做出对应的反应 let obj = &#123; name: '小明', age: 18 &#125; const p = new Proxy(obj, &#123; // target => 源数据 // 查 get(target, propName)&#123; console.log(`读取了P的$&#123;propName&#125;属性`) return target[propName] // return Reflect.get(target, propName) &#125;, // 改 + 增 set(target, propName, value)&#123; console.log(`修改了P的$&#123;propName&#125;属性，值为$&#123;value&#125;`) target[propName] = value &#125;, // 删 deleteProperty(target, propName)&#123; console.log(`删除了P的$&#123;propName&#125;属性`) return delete target[propName] // 真，假 &#125; &#125;) 5. vue数据驱动的原理及实现 数据驱动是vue优点之一 在vue中不会直接操作dom，通过数据驱动减少dom’的操作，从而优化性能 使数据可观测，模拟实现 //观测类 export class Observer &#123; constructor(value) &#123; //判断数组还是对象 this.value = value; if (Array.isArray(value)) &#123; //数组逻辑 &#125; else &#123; // 对象逻辑 this.walk(value) &#125; &#125; walk(obj) &#123; //专门拿对象key值的方法 const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, key[i]) &#125; &#125; &#125; //循环 每一个属性都变成可观测的 function defineReactive(obj, key, val) &#123; if (arguments.length === 2) &#123; val = obj[key]//val 少定义一个对象 &#125; if (typeof val === 'object') &#123; //递归 new Observer(val) &#125; Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get() &#123; console.log(`$&#123;key&#125;被读取了`); &#125;, set(newVal) &#123; console.log(`$&#123;key&#125;被修改了，新值为$&#123;newVal&#125;`); val = newVal &#125; &#125;) &#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://baozhacao.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://baozhacao.github.io/tags/Vue/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2022-11-08T11:05:00.000Z","updated":"2023-02-19T04:18:28.606Z","comments":true,"path":"2022/11/08/git-chang-yong-ming-ling/","link":"","permalink":"http://baozhacao.github.io/2022/11/08/git-chang-yong-ming-ling/","excerpt":"","text":"Git 是一个很强大的分布式版本控制系统。 1. 仓库操作常用命令 初始化GIt仓库 git init 查看文件状态 git status或git status -s 一次性将文件加入暂存区 git add . 将暂存区的文件提交到Git仓库 git commit -m&quot;提交信息&quot; 将本地仓库与远程仓库链接 git remote add origin 远程仓库地址 上传到远程仓库，如果出现错误，检查本地的。gitconfig文件 git push -u origin master&#x2F;&#x2F;上传到master分支，现在github一般默认main分支 2. 分支操作常用命令 查看本地分支 git branch 查看远程分支 git branch -r 创建本地分支 git branch [name] —-注意新分支创建后不会自动切换为当前分支 切换分支 git checkout [name] 创建新分支并立即切换到新分支 git checkout -b [name] 合并分支 git merge [name] —-将名称为[name]的分支与当前分支合并 删除分支 git branch -d 分支名称 第一次把分支推送到远程仓库 git push -u 远程仓库名 本地分支名：远程分支名 如果本地分支与远程分支一样时，可简化成一个 从远程仓库中下载分支 git checkout 远程仓库分支名 重命名 git checkout 重命名 远程仓库名&#x2F;远程分支名 把远程仓库分支的代码更新到本地 git pull","categories":[{"name":"git","slug":"git","permalink":"http://baozhacao.github.io/categories/git/"}],"tags":[{"name":"git常用命令","slug":"git常用命令","permalink":"http://baozhacao.github.io/tags/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}]},{"title":"Vue面试题1","slug":"vue应用层","date":"2022-11-08T09:15:49.000Z","updated":"2023-02-19T04:20:02.055Z","comments":true,"path":"2022/11/08/vue-ying-yong-ceng/","link":"","permalink":"http://baozhacao.github.io/2022/11/08/vue-ying-yong-ceng/","excerpt":"","text":"1. MVC与MVVM mvc中的c为control，为控制器，按照以前的做法都是把它存在后台，通过接口把数据存在后台。 缺点是前后端无法独立开发，必须等后端把数据写好前端才能开发。 前端太过依赖于后台，没有自己的数据储存中心。 mvvm把c换成了vm，有自己的数据储存中心，例如vue中的data，使前后端更加独立。 2. v-model原理 v-model是Vue实现数据双向绑定的功能，运用响应式原理。 &lt;input type=\"text\" v-model=\"message\"> 等同于 &lt;input type=\"text\" :value=\"message\" @input=\"message = $event.target.value\"> //在vue2中，数据的响应式原理使用的是Object.defineProperty let obj = &#123;&#125;, Object.defineProperty(obj,\"username\",&#123; //取值 get:function()&#123; console.log(\"取值\") &#125; set:function(val)&#123; //把拦截到的数据通过set放到页面上 document.getElementById(\"uName\").innerText = val &#125; &#125;) document.getElementById(\"uName\").addEvevtListener(\"kenup\",()=>&#123; //event obj.username = event.target.value &#125;) 上面代码的原理就是创建一个对象obj，用响应式拦截的方式给对象创建一个属性，给input时间添加方法，获得输入的内容，在通过拦截的set方法把内容呈现在页面上 3. data为什么是函数 闭包 —- 每个组件都有自己的私有作用域，组件之间不会相互影响。 4. v-if与v-show的区别 v-if —- 不满足条件不会渲染dom =&gt;适合单次隐藏。 v-show —- display:none =&gt;适合多次隐藏，不会影响性能。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://baozhacao.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://baozhacao.github.io/tags/Vue/"}]},{"title":"观察者和订阅发布模式","slug":"观察者和订阅发布模式","date":"2022-02-19T04:27:49.000Z","updated":"2023-02-19T04:20:59.770Z","comments":true,"path":"2022/02/19/guan-cha-zhe-he-ding-yue-fa-bu-mo-shi/","link":"","permalink":"http://baozhacao.github.io/2022/02/19/guan-cha-zhe-he-ding-yue-fa-bu-mo-shi/","excerpt":"","text":"观察者模式 观察者模式是指观察者（Observer）直接订阅主题（Subject），而主题被激活时，会触发观察者里的事件。 就像父母和宝宝一样，父母看着宝宝，宝宝只要发生变化，父母就会知道并及时处理。 // 观察者模式 // 宝宝 class Subject&#123; // 宝宝的状态 constructor(name)&#123; this.name = name; this.state = \"不开心\"; this.Observe = [] //存放观察者 &#125; // 将观察者放到自己身上 attach(ther)&#123; this.Observe.push(ther) &#125; //更新观察者的状态 setState(state)&#123; this.state = state; this.Observe.forEach(item=>&#123; // 把宝宝这个整个类传进去 item.update(this) &#125;) &#125; &#125; //父母 class Observe&#123; constructor(name)&#123; this.name = name &#125; update(Subject)&#123; // 接受宝宝类，打印当宝宝状态更改时的变化 console.log(this.name+Subject.name+Subject.state); &#125; &#125; let baby = new Subject('宝宝') let baba = new Observe(\"爸爸\") let mama = new Observe(\"妈妈\") baby.attach(baba) baby.attach(mama) //改变状态 baby.setState(\"开心\") 发布/订阅模式 订阅者把自己想要订阅的事件注册到调度中心，当发布者发布事件到调度中心时，调度中心会通知订阅者处理代码。 就相当于中间多了一个中介，由第三方统一调度。 这个模式就好像买报纸，出版报纸的人要把报纸送到报社，买的人要到报社去买，当有新报纸时，报社还会发通知给买报的人。 // on是订阅事件，emit是发布事件 // 邮局 let el = &#123; //粗存订阅者 _class: [], on(callback)&#123; this._class.push(callback) &#125;, emit(value)&#123; this._class.forEach(item=>&#123; item(value) &#125;) &#125; &#125; //订阅 el.on((value)=>&#123; console.log(\"张三买报纸\"+value); &#125;) el.on((value)=>&#123; console.log(\"李四买报纸\"+value); &#125;) //出版社发报纸 el.emit(\"光明日报\")","categories":[],"tags":[{"name":"观察者","slug":"观察者","permalink":"http://baozhacao.github.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85/"},{"name":"订阅发布","slug":"订阅发布","permalink":"http://baozhacao.github.io/tags/%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83/"}]}],"categories":[{"name":"布局模式","slug":"布局模式","permalink":"http://baozhacao.github.io/categories/%E5%B8%83%E5%B1%80%E6%A8%A1%E5%BC%8F/"},{"name":"js高级","slug":"js高级","permalink":"http://baozhacao.github.io/categories/js%E9%AB%98%E7%BA%A7/"},{"name":"es6","slug":"es6","permalink":"http://baozhacao.github.io/categories/es6/"},{"name":"Vue","slug":"Vue","permalink":"http://baozhacao.github.io/categories/Vue/"},{"name":"git","slug":"git","permalink":"http://baozhacao.github.io/categories/git/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://baozhacao.github.io/tags/HTML/"},{"name":"Flex，布局","slug":"Flex，布局","permalink":"http://baozhacao.github.io/tags/Flex%EF%BC%8C%E5%B8%83%E5%B1%80/"},{"name":"call","slug":"call","permalink":"http://baozhacao.github.io/tags/call/"},{"name":"apply","slug":"apply","permalink":"http://baozhacao.github.io/tags/apply/"},{"name":"bind","slug":"bind","permalink":"http://baozhacao.github.io/tags/bind/"},{"name":"es6","slug":"es6","permalink":"http://baozhacao.github.io/tags/es6/"},{"name":"Set","slug":"Set","permalink":"http://baozhacao.github.io/tags/Set/"},{"name":"Map","slug":"Map","permalink":"http://baozhacao.github.io/tags/Map/"},{"name":"js","slug":"js","permalink":"http://baozhacao.github.io/tags/js/"},{"name":"this","slug":"this","permalink":"http://baozhacao.github.io/tags/this/"},{"name":"Promise","slug":"Promise","permalink":"http://baozhacao.github.io/tags/Promise/"},{"name":"definePropert","slug":"definePropert","permalink":"http://baozhacao.github.io/tags/definePropert/"},{"name":"Proxy","slug":"Proxy","permalink":"http://baozhacao.github.io/tags/Proxy/"},{"name":"Reflect","slug":"Reflect","permalink":"http://baozhacao.github.io/tags/Reflect/"},{"name":"强引","slug":"强引","permalink":"http://baozhacao.github.io/tags/%E5%BC%BA%E5%BC%95/"},{"name":"弱引","slug":"弱引","permalink":"http://baozhacao.github.io/tags/%E5%BC%B1%E5%BC%95/"},{"name":"Vue","slug":"Vue","permalink":"http://baozhacao.github.io/tags/Vue/"},{"name":"git常用命令","slug":"git常用命令","permalink":"http://baozhacao.github.io/tags/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"name":"观察者","slug":"观察者","permalink":"http://baozhacao.github.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85/"},{"name":"订阅发布","slug":"订阅发布","permalink":"http://baozhacao.github.io/tags/%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83/"}]}